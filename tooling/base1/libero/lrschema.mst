!============================================================================*
!                                                                            *
!   lrschema.mst - Schema for MS Test programming                            *
!                                                                            *
!   Copyright (c) 1991-2009 iMatix Corporation                               *
!                                                                            *
!   Used to generate setup scripts compatible with the Microsoft Setup       *
!   toolkit (_MSTEST.EXE), and with Microsoft Test V1.  Generates a .MST     *
!   file and a .INC file.  Include both these in your installation list      *
!   as usual.  The .MST file is the main program.                            *
!                                                                            *
!   Define your own subroutines as 'SUB something STATIC'; I use another     *
!   syntax for modules so that Libero can tell the difference.               *
!                                                                            *
!   Usage:      Add this line to the start of your dialog file:              *
!               -schema=lrschema.mst                                         *
!                                                                            *
!               Accepts these options:                                       *
!               -opt:stack_max=nnn - size of subdialog stack (20)            *
!               -opt:template=xxxx - template file (template.mst)            *
!                                                                            *
!   ------------------ GPL Licensed Source Code ------------------           *
!   iMatix makes this software available under the GNU General               *
!   Public License (GPL) license for open source projects.  For              *
!   details of the GPL license please see www.gnu.org or read the            *
!   file license.gpl provided in this package.                               *
!                                                                            *
!   This program is free software; you can redistribute it and/or            *
!   modify it under the terms of the GNU General Public License as           *
!   published by the Free Software Foundation; either version 2 of           *
!   the License, or (at your option) any later version.                      *
!                                                                            *
!   This program is distributed in the hope that it will be useful,          *
!   but WITHOUT ANY WARRANTY; without even the implied warranty of           *
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
!   GNU General Public License for more details.                             *
!                                                                            *
!   You should have received a copy of the GNU General Public                *
!   License along with this program in the file 'license.gpl'; if            *
!   not, write to the Free Software Foundation, Inc., 59 Temple              *
!   Place - Suite 330, Boston, MA 02111-1307, USA.                           *
!                                                                            *
!   You can also license this software under iMatix's General Terms          *
!   of Business (GTB) for commercial projects.  If you have not              *
!   explicitly licensed this software under the iMatix GTB you may           *
!   only use it under the terms of the GNU General Public License.           *
!                                                                            *
!   For more information, send an email to info@imatix.com.                  *
!   --------------------------------------------------------------           *
!============================================================================*

!   You can use the template file to include project-specific code in the
!   generated code at various points.  This is a (better) alternative to
!   changing the schema in order to add your own project code.
!
!   The template file should contain these sections (each starts with a
!   keyword on a line, and ends with <END> on a line).  These sections may
!   be included in a newly-generated program (keywords are case-sensitive):
!
!   <HEADER>                    - program header comment
!   <DATA>                      - data definitions
!   <Initialise-The-Program>    - in Initialise-The-Program
!   <Get-External-Event>        - in Get-External-Event
!   <Terminate-The-Program>     - in Terminate-The-Program
!   <Any-Dialog-Module>         - any dialog module
!
:declare string $template = "template.mst"

:if not exist $source.mst
:output $source.mst
:echo "lr I: creating skeleton setup script $source.mst..."
''=============================================================================
''
''  $source.mst - setup script for My Product
''
''  Written:    $date     $author
''  Revised:    $date
''
:include optional $template "<HEADER>" "<END>"
''  Skeleton generated by LIBERO $version on $fulldate, $time.
''=============================================================================

'$$Define DEBUG                         ''  Define for script development
'$$Include 'setupapi.inc'
'$$Include 'msdetect.inc'

''Dialog ID's
Const WELCOME = 100

''Bitmap ID
Const BMP_LOGO = 1

:include optional $template "<DATA>" "<END>"

'********************************   M A I N   ********************************

BeginProgram:
    '$$Include '$dialog.inc'            ''  Go do dialog interpreter
EndProgram:

Quit:
    End                                 ''  Error exit


'*************************   INITIALISE THE PROGRAM   *************************

Static Sub $"initialise_the_program" ()
    Dim szInf As String

    SetBitmap "mscuistf.dll", BMP_LOGO
    SetTitle "Setup $Source"

    szInf = GetSymbolValue ("STF_SRCINFPATH")
    If szInf = "" Then
        szInf = GetSymbolValue ("STF_CWDDIR") + "$source.inf"
    End If
    ReadInfFile szInf

    $"the_next_event" = $"ok_event"
:   include optional $template "<Initialise-The-Program>" "<END>"
End Sub


'***************************   GET EXTERNAL EVENT   ***************************

Static Sub $"get_external_event" ()
:include optional $template "<Get-External-Event>" "<END>"
:if $included = 0

:endif
End Sub


'*************************   TERMINATE THE PROGRAM    *************************

Static Sub $"terminate_the_program" ()
    $"the_next_event" = $"terminate_event"
:include optional $template "<Terminate-The-Program>" "<END>"
End Sub

:close
:endif

!   Generate interpreter include file

:output $dialog.inc
:echo "lr I: generating code for $dialog..."
'----------------------------------------------------------------------------
'   Dialog data and code block - do not modify this code by hand
'   Generated by LIBERO $version on $fulldate, $time.
'   Schema file used: $schema
'----------------------------------------------------------------------------

'-- Declare subroutines -----------------------------------------------------

Declare Sub $"initialise_the_program"
Declare Sub $"get_external_event"
Declare Sub $"raise_exception" (event As Integer)
:do module
Declare Sub $name
:enddo
Declare Sub LR_fatalerror
Declare Sub LR_initialise

'-- Public variables used by the code modules -------------------------------

Global $"the_next_event"      As Integer   ' Next event from module
Global $"the_exception_event" As Integer   ' Exception event from module
Global $"exception_raised"    As Integer   ' TRUE if exception raised

'-- Symbolic constants and event numbers ------------------------------------

:if defaults
Const LR_defaults_state = $defaults
:endif
:do state
Const LR_STATE_$name = $number
:enddo

Const $"terminate_event"  = -1          ' Halts the dialog
Const LR_NULL_EVENT       = -2
:do event
Const $name               = $number
:enddo

'-- Variables used by dialog interpreter ------------------------------------

Global LR_event  As Integer             ' Event for state transition
Global LR_state  As Integer             ' Current dialog state
Global LR_savest As Integer             ' Saved dialog state
Global LR_index  As Integer             ' Index into vector table
Global LR_vecptr As Integer             ' Index into module vector
Global LR_modnbr As Integer             ' Number of module to execute
Global LR_mesg   As String              ' For pop-up error messages

Global LR_nextst As String              ' Next state for each event
Global LR_action As String              ' Action for each event
Global LR_module As String              ' Module list for action
Global LR_offset($vectors) As Integer

:if $states < 10
:   declare int nswid = 1               # Size of item in LR_nextst table
:else
:if $states < 100
:   declare int nswid = 2
:else
:   declare int nswid = 3
:endif all
:
:if $vectors < 10
:   declare int acwid = 1               # Size of item in LR_action table
:else
:if $vectors < 100
:   declare int acwid = 2
:else
:   declare int acwid = 3
:endif all
:
:if $modules < 10
:   declare int mowid = 1               # Size of item in LR_module table
:   declare string null = "0"
:else
:if $modules < 100
:   declare int mowid = 2
:   declare string null = "00"
:else
:   declare int mowid = 3
:   declare string null = "000"
:endif all
:
:if animate
:declare int count
:set count = $states - 1
Global LR_sname($count) As String
:set count = $events - 1
Global LR_ename($count) As String
Global LR_mname($modules) As String
:endif

:if module "Dialog-Call"
:  if not event "Return"
:     echo "lr E: you must define the 'Return' event"
:     exit 1
:  endif
:  declare int $stack_max = 20
:  declare int $dialog_call_modnbr
:  declare int $dialog_return_modnbr
:  do module                            #   Look at all modules to find
:    if '$name' = '$"dialog_call"'      #     numbers for -Call and -Return.
:       set $dialog_call_modnbr = $number + 1
:    endif
:    if '$name' = '$"dialog_return"'
:       set $dialog_return_modnbr = $number + 1
:    endif
:  enddo
Global LR_stack(1 to $stack_max) As Integer
Global LR_stack_size As Integer

:endif
'-- Dialog interpreter starts here ------------------------------------------

    LR_state = 0                        ' First state is always 0
:if module "Dialog-Call"
    LR_stack_size = 0                   ' Clear subdialog stack
:endif
    LR_initialise                       ' Initialse static strings
    $"initialise_the_program"
    While $"the_next_event" <> $"terminate_event"
        LR_event = $"the_next_event"
:if check
        If LR_event >= $events Or LR_event < 0 Then
            LR_mesg = "State" + Str$$(LR_state) + " - event" + Str$$(LR_event)
            LR_mesg = LR_mesg + " is out of range"
            LR_fatalerror
            Exit While
        End If
:endif
        LR_index = (LR_state * $events + LR_event) * $acwid + 1
        LR_index = Val(Mid$$(LR_action, LR_index, $acwid))
        LR_savest = LR_state

:if defaults
        '   If no action for this event, try the defaults state
        If LR_index = 0 Then
            LR_state = LR_defaults_state
            LR_index = (LR_state * $events + LR_event) * $acwid + 1
            LR_index = Val(Mid$$(LR_action, LR_index, $acwid))
:endif
:if check
            If LR_index = 0 Then
                LR_mesg = "State" + Str$$(LR_state) + " - event"
                LR_mesg = LR_mesg + Str$$(LR_event) + " is not accepted"
                LR_fatalerror
                Exit While
            End If
:endif
:if defaults
        End If
:endif

:if animate
      ''Debug.Print ""
      ''Debug.Print LR_sname(LR_state); ":"
      ''Debug.Print "    (--) "; LR_ename(LR_event)
:endif
:if check
        $"the_next_event" = LR_NULL_EVENT
:endif
        $"the_exception_event" = LR_NULL_EVENT
        $"exception_raised" = False

        '   Execute module list for state transition, 0 indicates end of list
        LR_vecptr = LR_offset(LR_index)
        LR_modnbr = Val(Mid$$(LR_module, LR_vecptr * $mowid + 1, $mowid))
        While LR_modnbr > 0 And Not $"exception_raised"
:if animate
            LR_mesg = "          + " + LR_mname(LR_modnbr)
            rc% = DoMsgBox (LR_mesg, "Trace", 0)
          ''Debug.Print "Module="; LR_mname(LR_modnbr)
:endif
            Select Case LR_modnbr       ' Execute the module
:set array_base = 1
:do module
                Case $number
                    $name
:enddo
:set array_base = 0
            End Select

            LR_vecptr = LR_vecptr + 1
            LR_modnbr = Val(Mid$$(LR_module, LR_vecptr * $mowid + 1, $mowid))
        Wend

        '   Handle exception if any was raised
        If $"exception_raised" Then
            If $"the_exception_event" <> LR_NULL_EVENT Then
                LR_event = $"the_exception_event"
            End If
            $"the_next_event" = LR_event
:if animate
          ''Debug.Print "    (=>) "; LR_ename(LR_event)
:endif
        Else
            LR_index = (LR_state * $events + LR_event) * $nswid + 1
            LR_state = Val(Mid$$(LR_nextst, LR_index, $nswid))
        End If
:if defaults
        If LR_state = LR_defaults_state Then
            LR_state = LR_savest
        End If
:endif
        If $"the_next_event" = LR_NULL_EVENT Then
            $"get_external_event"
:if check
            If $"the_next_event" = LR_NULL_EVENT Then
                LR_mesg = "No event set after event" + Str$$(LR_event)
                LR_mesg = LR_mesg + " in state" + Str$$(LR_state)
                LR_fatalerror
                Exit While
            End If
:endif
        End If
    Wend
    Goto EndProgram

'-- Standard subroutines used by dialog interpreter -------------------------

Sub $"raise_exception" (event As Integer) Static
    $"the_exception_event" = event
    $"the_exception_raised" = True
End Sub

Sub LR_fatalerror Static
    LR_mesg = LR_mesg + Chr$$(10) + "Source = $source"
  ''Debug.Print LR_mesg
    rc% = DoMsgBox (LR_mesg, "Libero Fatal Error", 0)
End Sub

Sub LR_initialise Static
:set row_width  = 42                    # If $row is longer, do overflow
:set number_fmt = "%ld"
:set row_first  = "%0$nswid\ld"
:set row_after  = "%0$nswid\ld"
:set number_fmt = "%ld"
:
    LR_nextst = ""
:do nextst
    LR_nextst = LR_nextst + "$row"
:  do overflow
    LR_nextst = LR_nextst + "$row"
:  enddo
:enddo

:set number_fmt = "%ld"
:set row_first  = "%0$acwid\ld"
:set row_after  = "%0$acwid\ld"
:set number_fmt = "%ld"
:
:set array_base = 1
    LR_action = ""
:do action
    LR_action = LR_action + "$row"
:  do overflow
    LR_action = LR_action + "$row"
:  enddo
:enddo

:set number_fmt = "%ld"
:set row_first  = "%0$mowid\ld"
:set row_after  = "%0$mowid\ld"
:set number_fmt = "%ld"
:
    LR_module = ""
:do vector
    LR_module = LR_module + "$row" + "$null"
:enddo
:set array_base = 0

:declare int offsetidx
:do vector
:   set offsetidx = $number + 1
    LR_offset($offsetidx) = $offset
:enddo
:if animate

:push $style
:option -style=normal
:do state
    LR_sname($number) = "$name"
:enddo
:do event
    LR_ename($number) = "$name"
:enddo
:set array_base = 1
:do module
    LR_mname($number) = "$name"
:enddo
:set array_base = 0
:pop $style
:option -style=$style
:endif
End Sub

:if module "Dialog-Call"
Static Sub $"dialog_call"
    If LR_stack_size < $stack_max Then
        LR_stack_size = LR_stack_size + 1
        LR_stack(LR_stack_size) = LR_state
    Else
        LR_mesg = "State " & LR_state & " - Dialog-Call overflow"
        LR_fatalerror
    End If
End Sub

Static Sub $"dialog_return"
    If LR_stack_size > 0 Then
        LR_state = LR_stack(LR_stack_size)
        LR_stack_size = LR_stack_size - 1
        exception_raised = True
        the_exception_event = $"return_event"
    Else
        LR_mesg = "State " & LR_state & " - Dialog-Return underflow"
        LR_fatalerror
    End If
End Sub
:endif

!   Generate stubs for all modules not yet defined in source file

:set stub_before="'"
:set stub_first="'"
:set stub_between="*"
:set stub_last="*"
:set module_line="Static Sub %s ()"
:internal initialise_the_program
:internal get_external_event
:do stubs $source.mst $dialog.inc

Static Sub $name ()
:include optional $template "<$module_name>" "<END>"
:if $included = 0
    ' needs work
:endif
End Sub
:enddo stubs
