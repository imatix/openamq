#
#   pwl_unix.gsl - PWL script for Unix
#
#   Copyright (c) 1996-2009 iMatix Corporation
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or (at
#   your option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   For information on alternative licensing for OEMs, please contact
#   iMatix Corporation.
#

##################################   MAIN   #################################

function unix_main
    >#!/bin/sh
    >#
    >#   Boom builder for $(pdl.name:) $(version)
    >#   Generated by iMatix Boom from $(pdl.workflow)
    bsd_license ("#")
    >#
    >#   Force environment variables to point to install location
    >#   Start by using final IBASE, then handle local -install path
    >#
    >boom_model_list () {
    >    set |
    >        awk 'BEGIN                      { FS="[=_]" }
    >             /^BOOM_MODEL_[A-Z0-9]*=1$/ { print $3  }'
    >}
    >boom_model_expand () {
    >    for MODEL in `boom_model_list`; do
    >        eval unset BOOM_MODEL_$MODEL
    >    done
    >    OLD_IFS=$IFS
    >    IFS=,
    >    for MODEL in $BOOM_MODEL; do
    >        MODEL=`echo $MODEL | tr \\[a-z\\] \\[A-Z\\]`
    >        eval BOOM_MODEL_$MODEL=1
    >        eval export BOOM_MODEL_$MODEL
    >    done
    >    IFS=$OLD_IFS
    >}
    >croak() {
    >    if [ -n "$*" ]; then
    >        echo "boom E: [$(pdl.acronym)]: $* - stop" 1>&2
    >    else
    >        echo "boom E: [$(pdl.acronym)]: stop" 1>&2
    >    fi
    >    exit 1
    >}
    >carp() {
    >    echo "boom I: [$(pdl.acronym)]: $*" 1>&2
    >}
    >trap 'croak "Interrupted"' INT
    >trap 'croak "Terminated"' TERM
    >trap 'croak "Quit"' QUIT
    unix_prepare_project ()
    >self=$0
    for pdl.set where (set.target?"unix") = "unix"
        >$(name:)="$(value:)"
        >export $(name:)
    endfor
    >MY_VERSION="$(version)"
    >#
    >#   Set default values for BOOM_MODEL
    >#
    >#   Default is release,mt on all platforms.
    >#
    >if [ -z "$BOOM_MODEL" ]; then
    >    BOOM_MODEL=release,mt
    >fi
    >boom_model_expand
    >if [ "$BOOM_MODEL_RELEASE" != "1" ]; then
    >    if [ "$BOOM_MODEL_DEBUG" != "1" ]; then
    >        BOOM_MODEL_RELEASE=1
    >        BOOM_MODEL="$BOOM_MODEL,release"
    >    fi
    >fi
    >if [ "$BOOM_MODEL_ST" != "1" ]; then
    >    if [ "$BOOM_MODEL_MT" != "1" ]; then
    >            BOOM_MODEL="$BOOM_MODEL,mt"
    >    fi
    >fi
    >if [ -z "$IBASE" ]; then
    >    carp "The IBASE variable is not set.  Please set it to the location where $(pdl.name) should be installed."
    >    exit 1
    >fi
    >if [ "$1" = "-v" ]; then
    >    BOOM_TRACE=1
    >    export BOOM_TRACE
    >    shift
    >fi
    if pdl.install <> ""
        >#   Let project access bin resources from IBASE
        >PATH=.:$IBASE/bin:$PATH; export PATH
        >PERLLIB=.:$IBASE/bin:$PERLLIB; export PERLLIB
        >IBASE=$IBASE$(pdl.install); export IBASE
    endif
    >if [ "$1" != "-install" ]; then
        >    #   Normal use, use IBASE
        >    PATH=.:$IBASE/bin:$PATH; export PATH
        >    PERLLIB=.:$IBASE/bin:$PERLLIB; export PERLLIB
        >    INCDIR_ALT=$IBASE/include; export INCDIR_ALT
        >    _LOCAL_BASE=
        >    _INSTALL_ROOT=$IBASE$(pdl.deploy)
    >else
        >    #   Building product, we use -install directory first, then IBASE
        >    CURDIR=`pwd`
        >    cd $2
        >    _LOCAL_BASE=`pwd`$(pdl.install)
        >    cd $CURDIR
        >    PATH=.:$_LOCAL_BASE/bin:$IBASE/bin:$PATH; export PATH
        >    PERLLIB=.:$_LOCAL_BASE/bin:$IBASE/bin:$PERLLIB; export PERLLIB
        >    INCDIR_ALT=$_LOCAL_BASE/include:$IBASE/include; export INCDIR_ALT
        >    shift
        >    shift
        >    _INSTALL_ROOT=$_LOCAL_BASE$(pdl.deploy)
    >fi
    >
    for pwl.action by name
        ># $(format_title (action.name, 77, "-"):)
        >
        >a_$(name:c)() {
        >:
        invoke_rule (name)
        >}
        >
    endfor
    for pwl.state
        >actions_$(name:c)() {
        for event where (internal?0) = 0
            >echo "$(event.name):"
            >$(format_block (event., '    echo "  ', '"', '.'):)
        endfor
        if defined (inherit)
            >actions_$(inherit:c)
        endif
        >    return
        >}
        >
    endfor
    >#   State machine starts here
    >#
    >firsttime=true
    >while [ "$1" -o "$firsttime" ]; do
    >  firsttime=
    >  state=$(pwl-> state.name)
    >  event=ok
    >  debug=
    >  export state event debug
    >  while [ -n "$state" ]; do
    >    if [ "$inherit_state" ]; then
    >        check_state=$inherit_state
    >        inherit_state=
    >    else
    >        check_state=$state
    >    fi
    >    case "$check_state" in
    for pwl.state
        >    $(name:c))
        >        if [ -n "$debug" ]; then
        >            echo "State: $(name)"
        >        fi
        >        case "$event" in
        >        "")
        >            if [ -n "$debug" ]; then
        >                echo "Get event from user"
        >            fi
        >            if [ "$1" ]; then
        >                event=$1
        >                shift
        >            else
        >                event=empty
        >            fi
        >            continue
        >        ;;
        for event
            >        $(name:c))
            >            if [ -n "$debug" ]; then
            >                echo "Event: $(name)"
            >            fi
            >            event=
            >            exception=
            for action
                >            if [ -n "$debug" ]; then
                >                echo "Action: $(name)"
                >            fi
                >            if [ -z "$exception" ]; then
                >                a_$(name:c)
                >            fi
            endfor
            if defined (nextstate)
                >            state=$(nextstate:c)
                >            if [ -n "$exception" ]; then
                >                continue
                >            fi
            else
                #    Process multiple actions on command line
                >            if [ -n "$1" -a -z "$exception" ]; then
                >                continue 2
                >            fi
                >            state=
            endif
            >        ;;
        endfor
        >        *)
        if defined (inherit)
            >            inherit_state=$(inherit:c)
        else
            >            echo "Unknown command - use one of:"
            >            echo ""
            >            eval "actions_$state"
            >            exit 1
        endif
        >        ;;
        >        esac
        >    ;;
    endfor
    >    esac
    >  done
    >done
endfunction

function unix_prepare_project
    #   Ensure PDL paths are correctly formatted
    pdl.rootdir = format_pathname (pdl.rootdir)
    pdl.deploy  = format_pathname (pdl.deploy)
    pdl.install = format_pathname (pdl.install)
    #   Force install and deploy paths to start with slash if not empty
    if pdl.install <> "" & string.substr (pdl.install, 0,,1) <> "/"
        pdl.install = "/" + pdl.install
    endif
    if pdl.deploy <> "" & string.substr (pdl.deploy, 0,,1) <> "/"
        pdl.deploy = "/" + pdl.deploy
    endif
    walk_project ("", , "unix_resolve_filetypes", "resolve_directories")
endfunction

#   Resolve non-portable filetypes, define 'ext' in all file entries
#
function unix_resolve_filetypes (path)
    file.location = format_pathname (file.location)
    if    filetype = "object"
        if file.model?"" = "cpp"
            file.ext = ".opp"
        else
            file.ext = ".o"
        endif
        file.binary = 1
    elsif filetype = "command"
        file.ext    = ""
        file.binary = 1
    elsif filetype = "library"
        file.ext    = ".a"
        file.binary = 1
    else
        file.ext    = ""
        file.binary = 0
    endif
endfunction


########################   REPORT HELP INFORMATION   ########################

.macro unix_report_help_information
    echo "The commands you can currently use on this project are:"
    echo ""
    eval "actions_$state"
.endmacro


########################   REPORT PROJECT VERSION   #########################

.macro unix_report_project_version ()
    echo "$(pdl.acronym)-$(pdl.version)"
.endmacro


########################   CHECK OPERATING CONTEXT   ########################

.macro unix_check_operating_context ()
    if [ -f ./stamp_stripped ]; then
        event=stripped
    elif [ -f ./stamp_source ]; then
        event=source
    else
        event=repository
    fi
.endmacro


#######################   CHECK PROJECT FILES EXIST   #######################

.macro unix_check_project_files_exist
.   walk_project ("", , "unix_check_project_files", "unix_check_push_dir", "unix_pop_dir")
.endmacro

.macro unix_check_project_files (path)
.   if generated = 0
.       unix_require_file ("")
.   endif
.endmacro

.macro unix_check_push_dir (path)
    if [ ! -d "$(directory.name)" ]; then
        croak "Directory $(directory.name) is missing"
    fi
.   unix_push_dir (my.path)
.endmacro

.macro unix_push_dir (path)
    PUSHDIR=`pwd`
    cd $(my.path)
.endmacro

.macro unix_pop_dir (path)
    cd $PUSHDIR
.endmacro

.macro unix_require_file (type, all_models)
.   if (file.target?"unix") = "unix" & shared = 0
.       if my.type = "" | count (distrib, count.[as] = my.type, count)
.           if defined (model) & !defined (my.all_models)
    if [ "$BOOM_MODEL_$(model:upper)" ]; then
.           endif
.           if (file.wildcard ?= "1")
    if [ "`echo $(name)$(ext)`" = "$(name)$(ext)" ]; then
	croak "$(name)$(ext) is missing"
    fi
.           else
    if [ ! -f "$(name)$(ext)" ]; then
        croak "$(name)$(ext) is missing"
    fi
.           endif
.           if defined (model) & !defined (my.all_models)
    fi
.           endif
.       endif
.   endif
.endmacro


#######################   CHECK SOURCE FILES EXIST   ########################

.macro unix_check_source_files_exist
.   walk_project ("", , "unix_check_source_files", "unix_push_dir", "unix_pop_dir")
.endmacro

.macro unix_check_source_files (path)
.   unix_require_file ("source")
.endmacro


#####################   CHECK ALL SOURCE FILES EXIST   ######################

.macro unix_check_all_source_files_exist
.   walk_project ("", , "unix_check_all_source_files", "unix_push_dir", "unix_pop_dir")
.endmacro

.macro unix_check_all_source_files (path)
.   unix_require_file ("source", 1)
.endmacro


#######################   CHECK BINARY FILES EXIST   ########################

.macro unix_check_binary_files_exist
.   walk_project ("", , "unix_check_binary_files", "unix_push_dir", "unix_pop_dir")
.endmacro

function unix_check_binary_files (path)
    unix_require_file ("binary")
endfunction


########################   PRODUCE GENERATED FILES   ########################

.macro unix_produce_generated_files
    carp "Generating files..."
.   walk_project ("", "unix_generate", "unix_generate", "unix_push_dir", "unix_pop_dir")
.   walk_project ("", "unix_gen_copy", "unix_gen_copy")
    echo "Source files successfully generated">stamp_generate
.endmacro

function unix_generate (path)
    for generate
        unix_handle_process_step ()
    endfor
endfunction

function unix_handle_process_step (all_models)
    for . where defined (name ()) as entity
        if name () = "execute" & (entity.target?"unix") = "unix"
            if defined (entity.command)
                if scope (file)
                    unix_command ("$(command:) $(file.name?)$(ext?)", my.all_models)
                else
                    unix_command (command, my.all_models)
                endif
            elsif defined (entity.script)
                include entity.script
            else
                filename = "$(file.name?)$(ext?)"
.               template 1
.                   gsl (entity.?'')
.               endtemplate
            endif
        elsif name () = "run"
            >    if [ "$BOOM_TRACE" ]; then
            >        RUN_COMMAND="./$(basename)"
            >    else
            >        RUN_COMMAND="./$(basename) -q"
            >    fi
            unix_command ("$RUN_COMMAND", my.all_models)
       elsif name () = "collect"
            >    rm -f $(into)
            if scope (directory)
                parent = "directory"
            else
                parent = "pdl"
            endif
            for file
                if count ($(parent).file, count.name = file.name, count) = 0
                   abort ("File '$(name)' specified in collection but not in project")
                endif
                unix_command ('cat $(name)>>$(into)', my.all_models)
            endfor
        endif
    endfor
endfunction

.macro unix_command (string, all_models, parallel)
.   if defined (model) & !defined (my.all_models)
    if [ "$BOOM_MODEL_$(model:upper)" ]; then
.   endif
    [ "$BOOM_TRACE" ] && echo "$(my.string:)"
.   if defined (my.parallel)
    if [ -z "$BOOM_CORES" ]; then
        $(my.string:) || croak "\\"$(my.string)\\" failed"
    else
        if [ "$FREE_SLOTS" = "0" ]; then
            wait
            FREE_SLOTS=$BOOM_CORES
        fi
        $(my.string:) || croak "\\"$(my.string)\\" failed" &
        FREE_SLOTS=`expr $FREE_SLOTS - 1`
    fi
.   else
    $(my.string:) || croak "\\"$(my.string)\\" failed"
.   endif
.   if defined (model) & !defined (my.all_models)
    fi
.   endif
.endmacro

function unix_gen_copy (path)
    for generate
        unix_handle_copy (my.path)
    endfor
endfunction

#   This has to be done outside a push/pop dir, because we use paths
#   relative to the project root directory.
#   copy from = directory                    in files
#   copy from = directory filename = name    in project/directory actions

function unix_handle_copy (path)
    if my.path = ""
        my.path = "."
    endif
    for copy
        my.pathname = format_pathname ([from])
        if scope (file)
            unix_command ('cp -p $(my.pathname)/$(name)$(ext) $(my.path)')
        else
            unix_command ('cp -p $(my.pathname)/$(filename) $(my.path)')
        endif
    endfor
endfunction


######################   PRODUCE ALL GENERATED FILES   ########################

.macro unix_produce_all_generated_files
    carp "Generating files..."
.   walk_project ("", "unix_generate_all", "unix_generate_all", "unix_push_dir", "unix_pop_dir")
.   walk_project ("", "unix_gen_copy", "unix_gen_copy")
    echo "Source files successfully generated">stamp_generate
.endmacro

.macro unix_generate_all (path)
.   for generate
.       unix_handle_process_step (1)
.   endfor
.endmacro


##########################   BUILD BINARY FILES   ###########################

.macro unix_build_binary_files
    carp "Building $(pdl.name)..."
    #   To prevent compatibility warnings...
    INCDIR=
    LIBDIR=
    export LIBDIR INCDIR
    if [ "$BOOM_TRACE" ]; then
        MY_COPTS=-v
    else
        MY_COPTS=-q
    fi
    if [ -n "$_LOCAL_BASE" ]; then
        MY_COPTS="$MY_COPTS -li $_LOCAL_BASE/include -ll $_LOCAL_BASE/lib"
    fi
.   unix_build_directory ("")
.endmacro

function unix_build_directory (path)
    pathsep = target.pathsep?"/"
    if my.path = ""
        my.parent = "pdl"
    else
        my.parent = "directory"
    endif

    #   Handle any 'copy' commands
    for $(my.parent).file where (file.target?"unix") = "unix"
        for build
            unix_handle_copy (my.path)
        endfor
    endfor

    #   We now work in the local directory
    if my.path <> ""
        unix_push_dir (my.path)
    endif

    #   Do any 'before' build actions
    for $(my.parent).actions where when = "before"
        for build
            unix_handle_process_step ()
        endfor
    endfor

    #   Build and compile files locally.
    >test -n "$BOOM_CORES" && FREE_SLOTS=$BOOM_CORES
    for $(my.parent).file where (file.target?"unix") = "unix"
        for build
            unix_handle_process_step ()
        endfor
        for build where count (compile, (count.[as]?"c") = "c", count)
            unix_command ('c $MY_COPTS $(basename)',,1)
        endfor
    endfor
    >test -n "$BOOM_CORES" && wait

    #   Replace compiled programs into local library
    if $(my.parent).library ?<> ""
        for $(my.parent).file where (file.target?"unix") = "unix"
            for build where count (replace, (count.[as]?"c") = "c", count)
                unix_command ('c $MY_COPTS -r $(library) $(basename)')
            endfor
        endfor
    endif

    #   Link main programs locally
    for $(my.parent).file where (file.target?"unix") = "unix"
        for build where count (link, (count.[as]?"c") = "c", count)
            unix_command ('c $MY_COPTS -L $(basename)',,1)
        endfor
    endfor
    >test -n "$BOOM_CORES" && wait

    #   Do any 'after' build actions
    for $(my.parent).actions where when = "after"
        for build
            unix_handle_process_step ()
        endfor
    endfor

    #   We now switch back to the project root directory
    if my.path <> ""
        unix_pop_dir ()
    endif

    #   Replace compiled programs into project library
    #   This will be done only if we compiled in a child directory
    #   but the library is defined at the project (PDL) level.
    if ($(my.parent).library?"") = ""
        for $(my.parent).file where (file.target?"unix") = "unix"
            for build where count (replace, (count.[as]?"c") = "c", count)
                if library <> ""
                    unix_command ('c $MY_COPTS -r $(library) $(my.path)$(basename)')
                endif
            endfor
        endfor
    endif

    #   Recurse into all child directories
    for $(my.parent).directory where (directory.target?"unix") = "unix"
        unix_build_directory (my.path + directory.name + pathsep)
    endfor
endfunction


######################   USE SOURCE CONTROL REVISION   ######################

.macro unix_use_source_control_revision
    if [ -d .svn ]; then
        SVN_REVISION="`svn info | awk '/^Revision:/ { print $2 }'`"
    else
        SVN_REVISION="svn"
    fi
    MY_VERSION=${MY_VERSION}-${SVN_REVISION}
.endmacro


#########################   BUILD SOURCE PACKAGES   #########################

function unix_build_source_packages
    package_type = "source"
    >    rm -f _package.lst
    walk_project ("", , "unix_package_file")
    unix_package_sources ()
endfunction

#   Packages zip and tar.gz files from _packages.lst

.macro unix_package_sources
.   archive = "$(acronym:c)-$MY_VERSION"
    echo "Source package successfully generated">stamp_source
    echo "stamp_source">>_package.lst
    carp "Building $(archive)-src.tar.gz..."
    zip  -rq _package.zip -@<_package.lst
    unzip -q _package.zip -d $(archive)
    rm -f $(archive)-src.tar.gz
    tar -cf  $(archive)-src.tar $(archive)
    gzip $(archive)-src.tar
    rm -f $(archive)-src.zip
    carp "Building $(archive)-src.zip..."
    zip -lrmq $(archive)-src.zip $(archive)
    rm _package.zip
    rm _package.lst
    rm stamp_source
.endmacro

.macro unix_package_file (path)
.   if count (distrib, count.[as] = package_type, count)
.       fullname = rootdir + my.path + name + ext
.       if (file.wildcard ?= "1")
    if [ "`echo $(fullname)`" != "$(fullname)" ]; then
        for file in `echo $(fullname)`; do
            echo $file>>_package.lst
        done
    fi
.       else
    if [ -f "$(fullname)" ]; then
        echo $(fullname)>>_package.lst
    fi
.       endif
.   endif
.endmacro


#########################   INSTALL DELIVERABLES   ##########################

.macro unix_install_deliverables
.   walk_project ("", , "check_install_file")
    carp "Installing $(pdl.name:) into $_INSTALL_ROOT..."
    if [ ! -d "$_INSTALL_ROOT" ]; then
        if mkdir -p $_INSTALL_ROOT; then
            :
        else
            croak "Could not create directory \\"$_INSTALL_ROOT\\""
        fi
    fi
.   walk_project_remap ("", "unix_install_action", "unix_install_file")
    if [ -f ./installer ]; then
.   unix_command ("sh ./installer")
    fi
.endmacro

.macro unix_install_action (path)
.   for install
.       unix_handle_process_step ()
.   endfor
.endmacro

.macro unix_install_file (path)
.   if defined (file.install) & (file.target?"unix") = "unix"
.       if pdl.deploy = ""
.           cur_path = file.install + "/"
.       else
.           cur_path = my.path
.       endif
.       last_path ?= ""
.       if cur_path <> last_path
    mkdir -p $_INSTALL_ROOT/$(cur_path)
.           last_path = cur_path
.       endif
.       if shared = 0 | class.file.exists (my.path + name + ext)
.           unix_command ('cp $(location)$(name)$(ext) $_INSTALL_ROOT/$(cur_path)$(rename?"")')
.           if file-> install.[as] ?= "command"
.               unix_command ('chmod 0755 $_INSTALL_ROOT/$(cur_path)$(rename?name+ext)')
.           else
.               unix_command ('chmod 0644 $_INSTALL_ROOT/$(cur_path)$(rename?name+ext)')
.           endif
.       endif
.   endif
.endmacro


#######################   REMOVE GENERATED SOURCES   ########################

.macro unix_remove_generated_sources
.   walk_project ("", , "unix_remove_generated_source")
.   walk_project ("", "unix_degen", "unix_degen", "unix_push_dir", "unix_pop_dir")
    rm -f $(acronym:c)_*.zip
    rm -f $(acronym:c)_*.tar.gz
.endmacro

.macro unix_remove_generated_source (path)
.   if generated & (file.binary?0) ?= 0
    rm -f $(my.path)$(name)$(ext)
.   endif
.endmacro

.macro unix_degen (path)
.   for degen
.       unix_handle_process_step ()
.   endfor
.endmacro


#######################   REMOVE GENERATED BINARIES   #######################

.macro unix_remove_generated_binaries
.   walk_project ("", , "unix_remove_generated_binary")
.   walk_project ("", "unix_clean", "unix_clean", "unix_push_dir", "unix_pop_dir")
.endmacro

.macro unix_remove_generated_binary (path)
.   if generated & (file.binary?0) ?= 1
    rm -f $(my.path)$(basename)$(ext)
.   endif
.endmacro

.macro unix_clean (path)
.   for clean
.       unix_handle_process_step ()
.   endfor
.endmacro


#######################   LIST ALL GENERATED FILES   #########################

function unix_list_all_generated_files
    walk_project ("", , "unix_list_generated")
    for pwl.target where defined (target.output)
        >    echo $(target.output)
    endfor
    >    echo Makefile
endfunction

function unix_list_generated (path)
    if generated
        >    echo $(my.path)$(name)$(ext)
    endif
endfunction


#########################   RUN REGRESSION TESTS   ##########################

.macro unix_run_regression_tests
.   have_tests = 0
.   walk_project ("", "unix_tests", "unix_tests", "unix_push_dir", "unix_pop_dir")
    #   Run local selftest script if present
    if [ -f ./selftest ]; then
.   unix_command ("sh ./selftest")
    fi
.endmacro

function unix_tests (path)
    for test
        if !have_tests
            >    carp "Running regression tests..."
            have_tests = 1
        endif
        unix_handle_process_step ()
    endfor
endfunction


############################   BUILD PROJECTS   #############################

.macro unix_build_projects ()
    rm -rf _install
    mkdir _install
.   if pdl.install <> ""
    mkdir _install$(pdl.install)
.   endif
    mkdir _install$(pdl.install)/lib
    mkdir _install$(pdl.install)/include
    mkdir _install$(pdl.install)/bin
.   unix_do_projects ("-install ../_install build install")
.endmacro

.macro unix_do_projects (action)
.   for pdl.project
.   unix_push_dir (directory)
    if [ -f boomake ]; then
        sh boomake $(my.action) || croak
    else
        croak "Project has not been configured - boomake is missing"
    fi
.   unix_pop_dir (directory)
.   endfor
.endmacro


###########################   COMPILE PROJECTS   ############################

function unix_compile_projects ()
    unix_do_projects ("compile")
endfunction


############################   REGEN PROJECTS   #############################

function unix_regen_projects ()
    unix_do_projects ("regen")
endfunction


############################   ALLGEN PROJECTS   ############################

function unix_allgen_projects ()
    unix_do_projects ("allgen")
endfunction


#############################   TEST PROJECTS   #############################

.macro unix_test_projects ()
.   unix_do_projects ("test")
    if [ -f ./selftest ]; then
.   unix_command ("sh ./selftest")
    fi
.endmacro


###########################   INSTALL PROJECTS   ############################

.macro unix_install_projects ()
.   unix_do_projects ("install")
    if [ -f ./installer ]; then
.   unix_command ("sh ./installer")
    fi
.endmacro


############################   CLEAN PROJECTS   #############################

.macro unix_clean_projects ()
    rm -rf _install
.   unix_do_projects ("clean")
    rm -f $(acronym:c)_*.zip
    rm -f $(acronym:c)_*.tar.gz
.endmacro


#####################   BUILD PRODUCT SOURCE PACKAGES   #####################

function unix_build_product_source_packages ()
    for pdl.distrib where type = "source"
        >    rm -f _package.lst
        walk_project ("", , "unix_package_file")
        for pdl.actions where when = "before"
            for distsrc
                unix_handle_process_step ()
            endfor
        endfor
        package_type = "source"
        for project as distrib_project
            for pdl.project where directory = distrib_project.directory
                for pdl
                    for set where (set.target?"unix") = "unix"
                        >    $(name:)="$(value:)"
                        >    export $(name:)
                    endfor
                    unix_push_dir (directory)
                    for actions
                        for distsrc
                            unix_handle_process_step ()
                        endfor
                    endfor
                    unix_pop_dir ()
                    unix_prepare_project ()
                    walk_project ("", , "unix_package_file")
                endfor
            endfor
        endfor
        for project
            >    echo "Source package successfully generated">$(directory)/stamp_source
            >    echo "$(directory)/stamp_source" >>_package.lst
        endfor
        unix_package_sources ()
        for project
            >    rm -f $(directory)/stamp_source
        endfor
    endfor
endfunction


####################   BUILD PRODUCT INSTALL PACKAGES   #####################

#  for all projects in this package
#  install the projects as specified
#  remove directories not wanted
#  invoke install as root

function unix_build_product_install_packages ()
    for pdl.distrib where type = "install"
        >    carp "Building $(name)..."
        >    rm -rf _install
        for project as distrib_project
            unix_push_dir (directory)
            >    if [ -f boomake ]; then
            >        sh boomake -install ../_install install || croak
            >    else
            >        carp "Project has not been built - boomake is missing"
            >    fi
            unix_pop_dir ()
        endfor
        for prune
            filename = format_pathname (filename)
            >    rm -rf _install$(pdl.install)/$(filename)
        endfor

        archive = "$(acronym:c)-$MY_VERSION"

        #  Rename install tree to create a package root
        >    mv _install $(archive)

        #  Default packager under Unix is pkg_tgz
        if count (packager) = 0
            unix_command ('pkg_tgz $(archive)')
        else
            for packager
                unix_command ('$(name) $(archive)')
            endfor
        endif
        >    rm -rf $(archive)
    endfor
endfunction
